# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RunwaysDataExtractor
                                 A QGIS plugin
 This plugin classifying runways types based on their patterns
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Jenya Brodski
        email                : jekab596@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import numpy as np
import cv2
import math
from geopy.distance import geodesic
from geopy.distance import Point
import pyproj
import matplotlib.pyplot as plt
from .airport_runways import AirportRunways
from .classifier import Classifier


class RunwaysDataExtractor:
    """
    A class that extruct runway data from proceeded image of digital map (OSM)
    
    """


    def __init__(self, img, path, icao, airportName):
        """
        Constructor

        :param path: Path to directory where image stored
        :param proceeded_img: image that analyzed by image processor
        :param source_img: image of airport area
        :param icao: icao code
        :param airportName: airport name
        """

        self.tfwData = self.openTfw(path + '.tfw')
        self.proceeded_img = img
        self.source_img = cv2.imread(path + ".tif")
        self.icao = icao
        self.airport = airportName


    def filterLines(self,lines):
        """
        Method that filter irrelevant runways that HoughLinesP method
        generate, it loops through lines, generate data, length and degrees.
        Initiate a list for lines, loop through lines data that has been sent
        append the first one and after that compare with a new one

        :param lines:
        :param ftwData:
        :return: Data about lines that filtered, length, degrees and list of coordinates [x1,y1,x2,y2]
        :rtype: str
        """
        if lines is None:
            return None
        a, b, c = lines.shape

        # Initialization a list for lines
        lines_data = []

        # Loop through lines that has been sent
        for i in range(a):
            l = lines[i][0]

            # compute the degree of each line
            deg = self.getDegrees(l)

            # calculate the length of each line
            length = self.getLen(l)

            px1, py1, px2, py2 = l
            coords = [px1, py1, px2, py2]

            # set of data about each line
            next_line = [coords, deg, length]

            if i < 1:
                # Add first one to the list
                lines_data.append(next_line)
                continue

            # Compare lines with a new line that generated
            self.compareToNewLine(lines_data, next_line)

        # Cast lines length to integer
        for i in range(len(lines_data)):
            l = lines_data[i]
            l[2] = int(l[2])

        return lines_data


    def getDegrees(self,l):
        """
        Calculate degrees of runway.
        As represented on  runways on Open Street Map canvas

        :param l: Runway
        :return: degrees of runway
        :rtype: tuple
        """
        x1,y1,x2,y2 = l

        # compute the degree in radians
        y = y2 - y1
        x = x2 - x1
        theta = math.atan2(y, x)
        theta = theta * (-1)

        # transform to degrees
        degree = math.degrees(theta)

        # transform degrees to degrees like at Qgis
        if (degree < 0):
            degree = int(degree + 11)
            posDeg = degree * (-1)
            s = posDeg + 100
            n = s + 180
            deg_tuple = (n, s)
        else:
            degree = int(degree - 11)
            n = 90 - degree
            s = 270 - degree
            deg_tuple = (n, s)

        return deg_tuple


    def getLen(self,points):
        """
        Method that calculate runway length

        :param points: Coordinates in numpy array
        :param tfwData: File that contain EPSG:3857 crs coordinate of the upper left corner in the image
        :return: Length of runway
        :rtype: float
        """

        # Convert coordinates of array to EPSG:3857 crs
        px1, py1, px2, py2 = points
        x1 = self.tfwData[0] * px1 + self.tfwData[1] * py1 + self.tfwData[4]
        x2 = self.tfwData[0] * px2 + self.tfwData[1] * py2 + self.tfwData[4]
        y1 = (self.tfwData[3]) * py1 + self.tfwData[2] * px1 + self.tfwData[5]
        y2 = (self.tfwData[3]) * py2 + self.tfwData[2] * px2 + self.tfwData[5]

        # Convert points to EPSG:4326 crs
        p = pyproj.Proj("+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
        n_x1, n_y1 = p(x1, y1, inverse=True)
        n_x2, n_y2 = p(x2, y2, inverse=True)
        p1 = Point(n_y1, n_x1)
        p2 = Point(n_y2, n_x2)

        # Find length
        d = geodesic(p1, p2).meters
        return d


    def compareToNewLine(self,lines_data, new_line):
        """
        Compare lines in list of line to find out if it
        is a new line that we have to add to lines data or
        a duplicate and trow it

        :param lines_data: list of lines with data about them
        :param new_line:  new line
        :return:
        """
        i = 0
        same_deg_flag = False
        equal_lines = False
        vector = [0] * len(lines_data)
        for prev_line in lines_data:
            deg1 = prev_line[1][0] - new_line[1][0]
            deg2 = prev_line[1][1] - new_line[1][1]
            if deg1 >= -5 and deg1 <= 5 and deg2 >= -5 and deg2 <= 5:
                same_deg_flag = True
                equal_lines = self.checkSimilarLines(prev_line, new_line)
                if equal_lines:
                    vector[i] = 1

            i += 1

        # add new line to list of lines
        if not same_deg_flag:
            lines_data.append(new_line)
            return

        # improvement of the same line and adding to list of lines or just adding to the list
        if same_deg_flag and vector.count(1) > 0:
            i = 0
            for j in vector:
                if j == 1:
                    prev_line = lines_data[i]
                    if prev_line[2] < new_line[2]:
                        lines_data.pop(i)
                        lines_data.append(new_line)
                        return
                i += 1
            return

        # lines are parallel, adding to the list
        lines_data.append(new_line)
        return


    def checkSimilarLines(self,prev_line,new_line):
        """
        Check if the lines are similar, the method do so
        by calculating the distance between previous line
        and one of the point of new line

        :param prev_line: Line that already in lines data list
        :param new_line: Line to check with
        :return: True if similar otherwise False
        :rtype: bool
        """

        # find the distance from line to a point
        x1, y1, x2, y2 = prev_line[0]
        x0 = new_line[0][0]
        y0 = new_line[0][1]
        m = (y2 - y1) / (x2 - x1)
        n = (m * (-1) * x1) + y1
        d = ((m * x0) - y0 + n) / math.sqrt(math.pow(m,2)+1)

        if d < 0:
            d = d * (-1)

        if d <= 11:
            return True
        return False


    def openTfw(self,path):
        """
        Open tfw file and extract the data contained in

        :param path: Path tfw file
        :return: Data that stored in the file
        :rtype: list
        """
        data = []
        with open(path, 'r') as f:
            for line in f:
                data.append(float(line))
        return data


    def getCenterCoords(self,size):
        """
        Get coordinates of the center of the image (of the airport)
        """
        x = self.tfwData[0] * (size[0]/2) + self.tfwData[1] * (size[1]/2) + self.tfwData[4]
        y = (self.tfwData[3]) * (size[1]/2) + self.tfwData[2] * (size[0]/2) +self.tfwData[5]
        return (x,y)


    def setRunwaysCoords(self,runway):
        """
        Set coordinates to runways of an airport

        :param runway: Runways
        :param tfwData: Coordinate of the rectangle where runways are
        :return:
        """
        a,d,b,e,c,f = self.tfwData
        x1,y1,x2,y2 = runway[0]

        x1 = a * x1 + b * y1 + c
        y1 = d * x1 + e * y1 + f
        x2 = a * x2 + b * y2 + c
        y2 = d * x2 + e * y2 + f

        runway[0][0] = x1
        runway[0][1] = y1
        runway[0][2] = x2
        runway[0][3] = y2


    def extractData(self):
        """
        Method that extract data from analyzed image, and encapsulate
        it in AirportRunways object

        :param img: Analyzed image
        :return:
        """
        
        grey = cv2.cvtColor(self.proceeded_img, cv2.COLOR_BGR2GRAY)

        # Find airport coordinates
        centerCoords = self.getCenterCoords(grey.shape)

        # Edges detection
        edges = cv2.Canny(grey, threshold1=0, threshold2=0)
        minLineLength = 70
        maxLineGap = 50

        # Find lines in an image
        lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 80, np.array([]), minLineLength , maxLineGap)

        # Filtering lines from duplicates
        fl = self.filterLines(lines)

        try:
            runwayNum = len(fl)
        except TypeError:
            runwayNum = 0

        r = 204
        g = 0
        b = 0

        if fl is not None:
            a = len(fl)

            # Drawing lines on the original image
            for i in range(a):
                l = fl[i]
                cv2.line(self.source_img, (l[0][0], l[0][1]), (l[0][2], l[0][3]), (r, g, b), 3, cv2.LINE_AA)
                self.setRunwaysCoords(fl[i])

        # Send data to AirportRunways object
        airportData = AirportRunways()
        airportData.setAirportName(self.airport)
        airportData.setIcaoCode(self.icao)
        airportData.setRunwaysNumber(runwayNum)
        airportData.setLocation(centerCoords)
        airportData.setRunwaysData(fl)
        airportData.setImg(self.source_img)
        classifier = Classifier()
        model = classifier.classify(airportData.getClassificationData())
        airportData.setModel(model)

        return airportData.getData()