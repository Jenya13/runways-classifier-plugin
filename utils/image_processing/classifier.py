# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Classifier
                                 A QGIS plugin
 This plugin classifying runways types based on their patterns
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Jenya Brodski
        email                : jekab596@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

class Classifier:
    """
    A class which classifies runways
    """


    def classify(self,data):
        """
        Method that maintenance the classification of airport runways
        it does classification to base models of runways otherwise call to
        other method to handle them.
        Classification to base models means that number of runways between 0 to 2.
        Classification represented as follow:
        Each cell represent a base type model :[ single , parallel , cross , open-v ]

        :param data: Airport data that contain his runways data
        :type data: list
        :return: Model to which algorithm classified
        :rtype: str
        """
        # Vector initialization
        vector = [0, 0, 0, 0]
        airport = data

        # No runway
        if airport["runways_num"] == 0:
            model = str(vector[0]) + str(vector[1]) + str(vector[2]) + str(vector[3])
            return model

        # One runway
        elif airport["runways_num"] == 1:
            vector[0] = 1
            model = str(vector[0]) + str(vector[1]) + str(vector[2]) + str(vector[3])
            return model

        # Two runways
        elif airport["runways_num"] == 2:
            rw1_deg1 = airport["data"][0][1][0]
            rw2_deg1 = airport["data"][1][1][0]
            if self.doParallel(rw1_deg1,rw2_deg1) :
                vector[1] = 1
                model = str(vector[0])+ str(vector[1]) + str(vector[2]) + str(vector[3])
                return model
            else:
                l1 = airport["data"][0][0]
                l2 = airport["data"][1][0]
                if self.doIntersect([l1[0], l1[1]], [l1[3], l1[3]], [l2[0], l2[1]], [l2[3], l2[3]]):
                    vector[2] = 1
                    model = str(vector[0]) + str(vector[1]) + str(vector[2]) + str(vector[3])
                    return model
                else:
                    vector[3] = 1
                    model = str(vector[0]) + str(vector[1]) + str(vector[2]) + str(vector[3])
                    return model

        # More than two runways
        elif airport["runways_num"] > 2:        # more than two runways
            return self.classifyComplexRunways(airport)

    def classifyComplexRunways(self,airport):
        """
        Classification of complex runways, more than two runways to classify.
        To do so we have to generate group, that means a list of tuples when
        the list represent relations between runways without repetitions and
        repetition of runway with it self.
        then we loop over this group with runways list, find relations and
        update the vector

        :param airport: Data about airport
        :return: Classification vector
        :rtype: str
        """

        # Group initialization
        group = self.generateGroup(airport["runways_num"])

        # Vector initialization :[ single , parallel , cross , open-v ]
        vector = [0, 0, 0, 0]

        # Loop over pairs of runways that in the group
        for pair in group:
            rw1_deg1 = airport["data"][pair[0]][1][0]
            rw2_deg1 = airport["data"][pair[1]][1][0]

            # Check if they are parallel
            if self.doParallel(rw1_deg1,rw2_deg1):
                vector[1] = vector[1] + 1
            else:
                l1 = airport["data"][pair[0]][0]
                l2 = airport["data"][pair[1]][0]

                # Check if they are intersect
                if self.doIntersect([l1[0], l1[1]], [l1[3], l1[3]], [l2[0], l2[1]], [l2[3], l2[3]]):
                    # Intersect
                    vector[2] = vector[2] + 1
                else:
                    # Open-v
                    vector[3] = vector[3] + 1

        model = str(vector[0]) + str(vector[1]) + str(vector[2]) + str(vector[3])

        return model

    def generateGroup(self,runway_num):
        """
        Generate group, list of tuples, when the list represent
        relations between runways without repetitions and
        repetition of runway with it self.

        :param runway_num: Number of runways in the airport
        :return: group of relations that have to be checked
        :rtype: list
        """

        # Group initialization
        group = []

        # Prepare group
        for i in range(0, runway_num):
            for j in range(0, runway_num):
                if j <= i:
                    continue
                t = (i, j)
                group.append(t)
        return group

    def doParallel(self,rw1_deg1,rw2_deg1):
        """
        Compare degrees of two runways
        and find out if they are parallel or not

        :param rw1_deg1: Runway degree
        :param rw2_deg1: Runway degree
        :return: True if runways parallel otherwise False
        :rtype: bool
        """
        deg = abs(rw1_deg1 - rw2_deg1)
        if deg <= 5:
            return True
        return False

    def doIntersect(self, p1, q1, p2, q2):
        """
        Compare points of two runways and find out
        if they are intersect or not

        :param p1: First point of runway one
        :param q1: Second point of runway one
        :param p2: First point of runway two
        :param q2: Second point of runway two
        :return: True if runways intersect otherwise False
        :rtype: bool
        """

        #Find the four orientations needed for general and
        #special cases
        o1 = self.orientation(p1, q1, p2)
        o2 = self.orientation(p1, q1, q2)
        o3 = self.orientation(p2, q2, p1)
        o4 = self.orientation(p2, q2, q1)

        #General case
        if o1 != o2 and o3 != o4:
            return True
        #Special Cases
        #p1, q1 and p2 are colinear and p2 lies on segment p1q1
        if o1 == 0 and self.onSegment(p1, p2, q1):
            return True
        #p1, q1 and q2 are colinear and q2 lies on segment p1q1
        if o2 == 0 and self.onSegment(p1, q2, q1):
            return True
        #p2, q2 and p1 are colinear and p1 lies on segment p2q2
        if o3 == 0 and self.onSegment(p2, p1, q2):
            return True
        #p2, q2 and q1 are colinear and q1 lies on segment p2q2
        if o4 == 0 and self.onSegment(p2, q1, q2):
            return True
        #Doesn't fall in any of the above cases
        return False

    def orientation(self,p, q, r):
        """
        find orientation of ordered triplet (p, q, r).

        :param p: First point of runway
        :param q: Second point of runway
        :param r: Point from the other runway
        :return: orientation
        :rtype: int
        """

        #The function returns following values
        #0 --> p, q and r are colinear
        #1 --> Clockwise
        #2 --> Counterclockwise
        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if val == 0:
            return 0        # colinear
        else:
            if val > 1:     # clock or counterclock wise
                return 2
            else:
                return 1

    def onSegment(self, p, q, r):
        """
        Given three colinear points p, q, r, the function checks if
        point q lies on line segment 'pr'

        :param p: First point of runway
        :param q: Second point of runway
        :param r: Point from the other runway
        :return:
        """
        if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]):
            return True
        return False







