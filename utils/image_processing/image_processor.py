# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ImageProcessor
                                 A QGIS plugin
 This plugin classifying runways types based on their patterns
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Jenya Brodski
        email                : jekab596@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import cv2


class ImageProcessor:
    """
    A class that processing images
    """

    @staticmethod
    def processImg(path):
        """
        This static method analyse given image of digital map,
        open street map.
        Returns an image that contains only runways

        :return: Image after rendering
        :rtype: numpy array
        """
    
        # reading image
        img = cv2.imread(path + ".tif")

        # changing the color channels order: B G R -> R G B
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # runways dark and light values:
        # light values of each channel
        light = (187, 187, 204)
        # dark values of each channel
        dark = (194, 193, 208)

        # prepare mask of the image
        mask = cv2.inRange(img, light, dark)

        # impose the mask on top of the original image
        # keeps every pixel in the given image if the corresponding value in the mask is 1
        result = cv2.bitwise_and(img, img, mask=mask)

        # spliting the channels
        r, g, b = cv2.split(result)

        ##########  Thresholding  ##########

        # thresholding each chanel with binary inverse
        ret, tr = cv2.threshold(r, 186, 255, cv2.THRESH_BINARY_INV)
        ret, tg = cv2.threshold(g, 186, 255, cv2.THRESH_BINARY_INV)
        ret, tb = cv2.threshold(b, 203, 255, cv2.THRESH_BINARY_INV)

        # merging the channels to one image
        # where the runway color is black (0,0,0) and the rest white (255,255,255)
        img1 = cv2.merge((tr, tg, tb))

        ##########  Blurring  ##########

        # defining kernel 8x8
        kernel = np.ones(shape=(8, 8), dtype=np.float32) / 25

        # filtering the image with kernel defined above
        filter = cv2.filter2D(img1, -1, kernel)

        # filtering with median blur and kernel of 5x5
        median_blur = cv2.medianBlur(filter, 5, 5)

        # thresholding the image to set grey pixels to black
        ret, img1 = cv2.threshold(median_blur, 163, 255, cv2.THRESH_BINARY)

        return img1

